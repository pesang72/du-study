# 10장: Redis Cluster (수평 확장)

## Cluster란?
Redis Cluster는 수평 확장(Scale-Out)을 위한 분산 데이터 저장 솔루션으로 단일 Redis 인스턴스의 메모리 한계를 극복하고, 여러 노드에 데이터를 분산 저장하여 무제한에 가까운 확장성을 제공

## 핵심 개념 상세

### 해시 슬롯 (Hash Slot) 시스템

**슬롯 분할 방식**
- 총 16,384개의 슬롯으로 키스페이스 분할
- 각 키는 CRC16(key) % 16384 해시 함수로 슬롯 번호 계산
- 슬롯 번호에 따라 담당 노드가 결정됨
- 예: "user:1000" → CRC16 계산 → 슬롯 1234 → Node-A 담당

**슬롯 분배 예시**

3개 마스터 노드 구성 시:
- Node-A: 슬롯 0~5460 (5461개)
- Node-B: 슬롯 5461~10922 (5461개)
- Node-C: 슬롯 10923~16383 (5461개)

**데이터 균등 분산의 원리**
- 해시 함수의 특성상 키가 각 슬롯에 균등하게 분배
- 새 노드 추가 시 기존 노드들의 슬롯 일부를 새 노드로 이동
- 예: 4번째 노드 추가 시 각 노드가 약 1365개씩 슬롯을 새 노드에 이양

### 클러스터 토폴로지

**최소 구성 요구사항**
- 최소 3개 마스터 노드 필요 (과반수 합의를 위한 홀수 권장)
- 각 마스터는 1개 이상의 슬레이브 보유 권장
- 실제 운영: 6개 노드 (마스터 3개 + 슬레이브 3개) 구성이 일반적

**가십 프로토콜 (Gossip Protocol)**
- 모든 노드가 서로 직접 통신 (Full Mesh 구조)
- 주기적으로 노드 상태, 슬롯 매핑 정보 교환
- 장애 감지 및 페일오버를 분산으로 처리
- 예: Node-A가 Node-B 장애 감지 → 다른 모든 노드에 정보 전파

**자동 장애 감지 및 복구**
- 마스터 노드 장애 시 해당 슬레이브가 자동 승격
- 과반수 마스터가 살아있어야 클러스터 정상 동작
- 예: 6개 노드 중 마스터 2개 장애 → 마스터 1개만 남음 → 클러스터 읽기 전용 모드

## 클러스터 제약사항과 해결책

### 다중 키 연산 제약

**문제 상황**
- 서로 다른 슬롯의 키들은 동시에 처리할 수 없음
- MGET, MSET 등의 다중 키 명령어 실행 시 에러 발생
- 예: "user:100"(슬롯 1234)과 "order:200"(슬롯 5678)을 동시에 조회 불가

**해시 태그 해결법**

잘못된 키 설계 (서로 다른 슬롯에 분산):
- user:1000:profile → 슬롯 1234
- user:1000:preferences → 슬롯 5678
- user:1000:sessions → 슬롯 9012

문제 상황:
- 사용자 프로필 업데이트 시 3개 키를 동시에 수정해야 함
- MSET 명령어 실행 시 "CROSSSLOT Keys in request don't hash to the same slot" 에러
- 각각 개별 SET 명령어로 3번 요청 → 네트워크 비용 증가

올바른 키 설계 (해시 태그 사용):
- {user:1000}:profile → 슬롯 1234
- {user:1000}:preferences → 슬롯 1234
- {user:1000}:sessions → 슬롯 1234

해결 결과:
- 모든 키가 같은 슬롯 1234에 저장
- MSET {user:1000}:profile "..." {user:1000}:preferences "..." 정상 실행
- 사용자별 데이터 원자적 업데이트 가능

### Lua 스크립트 제약

**제약 내용**
- 스크립트 내에서 접근하는 모든 키가 같은 슬롯에 있어야 함
- 여러 슬롯의 키를 다루는 복잡한 스크립트 실행 불가
- 예: 사용자 정보와 주문 정보를 동시에 업데이트하는 스크립트

**해결 방안**
- 해시 태그로 관련 키들을 같은 슬롯에 배치
- 스크립트를 여러 개로 분할하여 각각 실행
- 애플리케이션 레벨에서 트랜잭션 로직 구현

### 리다이렉션 처리 메커니즘

**MOVED 리다이렉션**
- 클라이언트가 잘못된 노드에 요청했을 때 발생
- 올바른 노드 정보를 응답으로 받아 재요청
- 예: 슬롯 1234의 키를 Node-B에 요청 → Node-A 주소 반환 → Node-A로 재요청

**ASK 리다이렉션**
- 슬롯 마이그레이션 중 발생하는 임시 리다이렉션
- 요청을 임시로 다른 노드로 전달
- Spring Boot에서 자동 처리되므로 개발자는 신경 쓸 필요 없음

## 성능 최적화 전략

**키 설계 최적화**
- 관련 데이터를 해시 태그로 그룹핑
- 핫스팟 방지를 위한 키 분산 설계

핫스팟 방지 예시:
- 기존: log:2024-01-01:14:30 → 개선: log:2024-01-01:14:30:r001
- 기존: stats:daily:2024-01-01 → 개선: stats:daily:2024-01-01:shard01
- 기존: session:morning:batch → 개선: session:morning:batch:a1b2

**배치 처리 최적화**
- 슬롯별로 키 그룹화 후 파이프라인 사용
- 같은 슬롯 내에서만 파이프라인 효과 있음
- 크로스 슬롯 배치 작업은 순차 처리

**연결 관리 최적화**
- 클러스터 환경에서는 더 많은 연결 필요
- 각 노드별로 별도 연결 풀 유지
- 적절한 타임아웃 설정으로 장애 노드 빠른 감지

## 클러스터 모니터링

### 클러스터 상태 확인
- CLUSTER INFO 명령어로 전체 상태 확인
- cluster_state: ok/fail 상태 모니터링
- cluster_slots_assigned: 16384 (모든 슬롯 할당 확인)

### 노드별 상태 모니터링
- 각 노드의 역할 (master/slave)
- 담당 슬롯 개수 및 범위
- 노드 간 연결 상태 (connected/disconnected)

### 성능 지표 모니터링
- 슬롯 분산도: 각 노드별 키 개수 균형
- 네트워크 지연: 노드 간 가십 프로토콜 지연
- 마이그레이션 진행률: 슬롯 이동 시 진행 상황

---

# Sentinel vs Cluster 선택 가이드

## Sentinel (고가용성 중심)

### 적합한 상황
- 데이터 크기가 단일 노드 메모리로 충분 (보통 32GB 이하)
- 복잡한 다중 키 연산이나 트랜잭션이 많은 경우
- 운영 복잡도를 최소화하고 싶은 경우
- 개발팀의 Redis 경험이 제한적인 경우

### 장점
- 설정과 운영이 상대적으로 단순
- 모든 Redis 명령어와 기능 사용 가능
- 네트워크 오버헤드가 낮음
- 디버깅과 트러블슈팅이 쉬움

### 단점
- 단일 노드 메모리 한계
- 수직 확장만 가능 (CPU, 메모리 업그레이드)
- 마스터 노드에 모든 쓰기 트래픽 집중

## Cluster (확장성 중심)

### 적합한 상황
- 데이터 크기가 단일 노드 메모리를 초과
- 높은 쓰기 처리량이 필요한 경우
- 무제한에 가까운 확장성이 필요한 경우
- 단일 키 기반 연산이 주를 이루는 경우

### 장점
- 수평 확장으로 거의 무제한 용량
- 쓰기 트래픽을 여러 노드에 분산
- 노드별 독립적인 페일오버
- 부분 장애 시에도 서비스 지속 가능

### 단점
- 설정과 운영이 복잡
- 다중 키 연산에 제약
- 네트워크 오버헤드 증가
- 애플리케이션 설계 시 클러스터 고려 필요

## 구체적 선택 기준

### 데이터 크기 기준
- 16GB 이하: Sentinel 권장
- 16GB~64GB: 성장 가능성 고려하여 선택
- 64GB 이상: Cluster 권장

### 트래픽 패턴 기준
- 읽기 중심, 복잡한 쿼리: Sentinel
- 쓰기 중심, 단순한 키-값 조회: Cluster
- MGET, Lua 스크립트 많이 사용: Sentinel

### 운영 역량 기준
- Redis 초급 수준: Sentinel
- Redis 숙련 수준: 요구사항에 따라 선택
- 전담 DBA 있음: Cluster도 고려 가능

---

# 공통 운영 가이드

## 데이터 일관성 고려사항

### 비동기 복제의 특성
- 마스터에서 슬레이브로 데이터 복제가 비동기로 진행
- 마스터 장애 시 마지막 몇 초간의 데이터 손실 가능
- 네트워크 지연 시 복제 지연(replication lag) 발생

### 일관성 보장 방법
- WAIT 명령어로 동기식 복제 사용 (성능 저하 주의)
- 중요한 데이터는 별도 영속성 저장소에 동시 저장
- 애플리케이션 레벨에서 데이터 정합성 검증

## 모니터링 필수 지표

### 시스템 리소스
- CPU 사용률: 80% 이상 시 성능 저하
- 메모리 사용률: 90% 이상 시 OOM 위험
- 네트워크 I/O: 대역폭 한계 근접 시 지연 증가

### Redis 특화 지표
- 초당 명령어 수 (ops/sec)
- 키 만료율 및 메모리 조각화
- 복제 지연 시간 (master_repl_offset - slave_repl_offset)
- 연결 수 및 연결 실패율

### Sentinel/Cluster 특화
- 페일오버 발생 빈도 및 소요 시간
- 노드 간 통신 지연 시간
- 슬롯 분산도 (Cluster의 경우)

## 백업 및 복구 전략

### 백업 방식 선택
- RDB: 특정 시점 스냅샷, 복구 속도 빠름
- AOF: 모든 쓰기 명령어 로그, 데이터 손실 최소
- 혼합 방식: RDB + AOF 조합으로 안정성과 성능 균형

### 백업 자동화
- 정기적인 RDB 스냅샷 생성 (예: 매일 새벽 2시)
- AOF rewrite를 통한 로그 파일 크기 관리
- 백업 파일을 별도 스토리지에 보관

### 복구 절차 검증
- 정기적으로 백업 파일을 이용한 복구 테스트
- 복구 시간 측정 및 RTO/RPO 계산
- 부분 장애와 전체 장애 시나리오 대비

## 성능 튜닝 포인트

### 메모리 최적화
- 적절한 데이터 구조 선택 (Hash vs String vs List)
- 키 이름 최적화 (짧고 의미있는 이름)
- TTL 설정으로 불필요한 데이터 자동 정리

### 네트워크 최적화
- Pipeline 사용으로 RTT 최소화
- 배치 명령어 활용 (MGET, MSET)
- 적절한 타임아웃 설정

### 설정 튜닝
- maxmemory-policy 설정 (LRU, LFU 등)
- tcp-keepalive 설정으로 끊어진 연결 감지
- client-output-buffer-limit으로 메모리 보호

---

# 장애 대응 가이드

## 일반적 장애 시나리오

### 메모리 부족 (OOM)
- 증상: 새로운 키 저장 실패, 성능 급격히 저하
- 대응: 불필요한 키 삭제, TTL 설정, 메모리 증설
- 예방: maxmemory 설정과 적절한 eviction policy

### 네트워크 분할
- 증상: 노드 간 통신 실패, false positive 페일오버
- 대응: 네트워크 복구 후 클러스터 상태 확인
- 예방: 적절한 타임아웃과 쿼럼 설정

### 슬로우 쿼리
- 증상: 응답 시간 증가, CPU 사용률 상승
- 대응: SLOWLOG 확인, 문제 쿼리 최적화
- 예방: 복잡한 연산은 애플리케이션 레벨에서 처리

## Sentinel 특화 장애 대응

### 페일오버 무한 반복
- 원인: 네트워크 불안정, 부적절한 설정
- 해결: 타임아웃 값 조정, 네트워크 환경 점검

### Split-brain 상황
- 원인: 네트워크 분할로 여러 마스터 동시 존재
- 해결: min-slaves-to-write 설정, 수동 복구

## Cluster 특화 장애 대응

### 슬롯 커버리지 부족
- 증상: cluster_state가 fail, 일부 키 접근 불가
- 해결: 장애 노드 복구 또는 슬롯 재할당

### 노드 간 통신 장애
- 증상: 가십 프로토콜 실패, 토폴로지 불일치
- 해결: 네트워크 연결성 확인, 클러스터 토폴로지 수동 복구