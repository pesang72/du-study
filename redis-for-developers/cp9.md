# 9장: Redis Sentinel (고가용성)

## Sentinel이란?
Redis Sentinel은 고가용성(High Availability)을 제공하는 분산 모니터링 시스템입니다. 단순한 마스터-슬레이브 복제에서 한 단계 더 나아가, 장애 상황을 자동으로 감지하고 복구하는 자동화된 운영 도구입니다.

## 핵심 개념 상세

### Sentinel의 4가지 핵심 역할

**1. 모니터링 (Monitoring)**
- 마스터와 슬레이브 인스턴스를 지속적으로 ping으로 상태 확인
- 응답 시간과 연결 상태를 실시간 추적
- 각 Sentinel은 독립적으로 모니터링 수행
- 예: 매 1초마다 PING 명령어를 보내서 Redis 인스턴스 상태 확인

**2. 알림 (Notification)**
- 로그 파일에 상세한 장애 정보 기록
- API를 통한 외부 모니터링 시스템 연동 가능

**3. 자동 페일오버 (Automatic Failover)**
- 마스터 장애 시 가장 적합한 슬레이브를 새 마스터로 승격
- 다른 슬레이브들을 새 마스터에 연결하도록 재구성
- 장애가 발생한 기존 마스터가 복구되면 슬레이브로 전환
- 예: 마스터 A 장애 → 슬레이브 B를 마스터로 승격 → 슬레이브 C를 새 마스터 B에 연결

**4. 설정 제공자 (Configuration Provider)**
- 클라이언트에게 현재 활성화된 마스터의 주소 정보 제공
- 페일오버 완료 후 새로운 마스터 정보를 클라이언트에 전달
- 서비스 디스커버리 역할 수행
- 예: Spring Boot 애플리케이션이 Sentinel에 "현재 마스터 주소가 뭐야?"라고 물어보면 실시간 주소 반환

### 장애 감지 메커니즘 상세

**주관적 다운 (SDOWN - Subjectively Down)**
- 개별 Sentinel이 down-after-milliseconds 시간 동안 응답 없음을 감지
- 네트워크 지연이나 일시적 문제일 수 있어 즉시 페일오버 하지 않음
- 각 Sentinel이 독립적으로 판단하는 "의심" 단계
- 예: Sentinel-1이 마스터에 5초간 ping 응답 없음 → "이 마스터 뭔가 이상한데?" (SDOWN)

**객관적 다운 (ODOWN - Objectively Down)**
- 설정된 쿼럼(quorum) 수 만큼의 Sentinel이 SDOWN에 동의할 때 선언
- 예: 쿼럼이 2이면 3개 Sentinel 중 2개가 SDOWN 판단해야 ODOWN
- ODOWN 선언되면 페일오버 프로세스 시작
- 예: Sentinel-1, Sentinel-2가 모두 "마스터 이상해" 판단 → "확실히 마스터 죽었다" (ODOWN)

**쿼럼 (Quorum)**
- ODOWN 판단에 필요한 최소 Sentinel 수
- Split-brain 문제 방지를 위해 전체 Sentinel 수의 과반수로 설정 권장
- 예: Sentinel 3개 → 쿼럼 2, Sentinel 5개 → 쿼럼 3
- 잘못된 예: Sentinel 2개에서 쿼럼 1 → 네트워크 분할 시 두 개가 각각 페일오버 시도 가능

## 페일오버 과정 상세

**1. 장애 감지 (Detection)**
- Sentinel들이 마스터에 ping 전송 → 응답 없음
- down-after-milliseconds 시간 경과 → SDOWN 판단
- 다른 Sentinel들과 상태 정보 교환
- 예: 30초간 마스터 응답 없음 → 3개 Sentinel 중 2개가 SDOWN 판단

**2. 합의 과정 (Consensus)**
- 쿼럼 수만큼 SDOWN 판단 → ODOWN 선언
- 페일오버를 진행할 Sentinel 선출 (리더 선출)
- 선출된 Sentinel이 페일오버 프로세스 주도
- 예: Sentinel-1이 리더로 선출되어 페일오버 진행

**3. 새 마스터 선택 (Master Selection)**

슬레이브들 중 가장 적합한 노드 선택 기준:
- 가장 최신 데이터를 가진 슬레이브 (복제 지연 최소)
- 우선순위가 높은 슬레이브 (slave-priority 설정값)
- 네트워크적으로 가장 가까운 슬레이브
- 예: 슬레이브-A(지연 10ms), 슬레이브-B(지연 100ms) → 슬레이브-A 선택

**4. 승격 및 재구성 (Promotion & Reconfiguration)**
- 선택된 슬레이브를 마스터로 승격: SLAVEOF NO ONE 명령
- 다른 슬레이브들을 새 마스터에 연결: SLAVEOF new-master-ip port 명령
- 클라이언트들에게 새 마스터 정보 전달
- 예: 슬레이브-A → 새 마스터, 슬레이브-B → 새 마스터의 슬레이브로 재연결

## 운영 시 주의사항

### 네트워크 분할 (Split-Brain) 시나리오

**시나리오: 전자상거래 사이트 Redis 장애**

초기 구성:
- 마스터 Redis: 서울 IDC (사용자 세션 데이터 저장)
- 슬레이브 Redis: 부산 IDC
- Sentinel: 서울 2개, 부산 1개 (쿼럼 2)

장애 발생:
1. 14:00 - 서울-부산 네트워크 연결 끊어짐
2. 서울 Sentinel 2개가 부산 마스터 응답 없다고 판단
3. 쿼럼 2 달성 → 부산 슬레이브를 새 마스터로 승격
4. 결과: 마스터 2개 동시 존재

문제 상황:
- 서울: 새 마스터 (빈 데이터) ← 신규 로그인 사용자
- 부산: 기존 마스터 (실제 세션 데이터) ← 기존 로그인 사용자
- 데이터 불일치로 일부 사용자 강제 로그아웃

해결 방법:
- min-slaves-to-write 2 설정
- 슬레이브 2개 연결되지 않으면 마스터 쓰기 중단
- 네트워크 분할 시 두 마스터 모두 쓰기 불가 → 데이터 일관성 보장

### 데이터 일관성 이슈

**시나리오: 결제 시스템 데이터 손실**

상황:
- 사용자가 100만원 상품 결제 완료
- Redis 마스터에 결제 완료 상태 저장
- 슬레이브로 복제 진행 중 마스터 서버 갑작스런 전원 차단

문제:
- 마스터: 결제 완료 데이터 저장 (메모리에만 존재, 미복제)
- 슬레이브: 결제 전 상태 (복제 지연으로 최신 데이터 없음)
- 페일오버 후 결제 완료 데이터 소실

실제 피해:
- 고객은 결제했지만 시스템에서 미결제로 처리
- 중복 결제 또는 주문 취소 발생
- 고객 불만 및 매출 손실

해결 방법:
- WAIT 명령어 사용: WAIT 1 1000 (1개 슬레이브에 1초 내 복제 대기)
- 중요 데이터는 DB와 Redis 동시 저장
- AOF 설정으로 디스크 영속성 보장

### 성능 고려사항

**시나리오 1: 과민한 장애 감지 (down-after-milliseconds 1000)**

상황:
- 새벽 2시 정기 백업으로 Redis 마스터 1초간 응답 지연
- Sentinel이 1초 내 응답 없다고 SDOWN 판단
- 3개 Sentinel 모두 SDOWN → 불필요한 페일오버 발생

문제점:
- 정상 상황에서도 페일오버 빈발
- 슬레이브가 마스터 역할 수행하며 성능 저하
- 운영진 불필요한 알람 및 대응

**시나리오 2: 둔감한 장애 감지 (down-after-milliseconds 60000)**

상황:
- 마스터 서버 하드웨어 장애로 완전 다운
- Sentinel이 60초 후에야 장애 감지
- 60초간 모든 쓰기 작업 실패

문제점:
- 장애 감지 지연으로 서비스 다운타임 연장
- 고객 로그인, 주문 등 핵심 기능 60초간 중단
- 매출 손실 및 고객 이탈

적절한 설정:
- down-after-milliseconds 5000-10000 (5-10초)
- 네트워크 환경과 서비스 중요도에 따라 조정
- 모니터링으로 false positive 비율 확인 후 튜닝